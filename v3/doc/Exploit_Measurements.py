import numpy as np
import os
import matplotlib.pyplot as plt
from functools import reduce
from scipy import stats
import math

def ns(ns):
    return ns / (1000 * 1000)


def gcd(*numbers):
    """Return the greatest common divisor of the given integers"""
    from fractions import gcd
    return reduce(gcd, numbers)

def lcm(*numbers):
    """Return lowest common multiple."""
    def lcm(a, b):
        return (a * b) // gcd(a, b)
    return reduce(lcm, numbers, 1)

# Takes an multidimensional list and plots it in one plot.
# Output is the filename (relative path) of the saved plot (must end with .png)
def plot(values, output, title, x_label='', y_label=''):
    fig, axes = plt.subplots()
    axes.plot(values, linewidth=0.5)
    axes.set_title(title)
    axes.set_ylabel(y_label)
    axes.set_xlabel(x_label)
    plt.autoscale(enable=True, axis='x', tight=True)
    fig.savefig(output)
    #plt.show()
    plt.close(fig)

def sufficentTest(list):
    #(phase, tEmax; tDmax)

    n = len(list)
    sum = 0.0
    for vars in list:
        minVar = min(vars[0], vars[2])
        sum += (float(vars[1]) / minVar)

    comp = 1 #n * (pow(2, (1/n)) - 1)
    u = sum <= comp

    print("sufficentTest for " + str(list))
    print('sum {}, comp {}, u {}'.format(sum, comp, u))

def necessaryTest(list):
    #(Pmin, tEmax; tDmax)

    divisors = list()
    for x in list:
        divisors.append(x[2])

    kgv = lcm(divisors)

    intervalls = list()
    for x in list:
        for i in range(0, kgv, x[2]):
            intervalls.append(i)




    for I in intervalls:

        sum = 0
        for vars in list:
            upper = I + vars[0] - vars[2] - 0
            divisor = vars[0]

            result = math.floor((upper / divisor)) * vars[1]
            sum += result

        print("I {}, sum {}".format(str(I), str(sum)))



def main():
    files = list()
    for file in os.listdir('./'):
        if file.endswith('.csv'):
            name = file.split('.')[0]
            tmp = np.genfromtxt(file, delimiter=',')
            tmp = tmp[:-1]
            tmp = tmp[tmp < np.percentile(tmp, 90)]

            mean = np.mean(tmp)
            median = np.mean(tmp)
            maximum = np.max(tmp)
            mininum = np.min(tmp)
            print('')
            print("file " + name + " count " + str(len(tmp)))
            print('min {} ns, {} ms'.format(mininum, ns(mininum)))
            print("mean {} ns, {} ms".format(str(mean), str(ns(mean))))
            print("median {} ns, {} ms".format(str(median), str(ns(median))))
            print("max {} ns, {} ms".format(str(maximum), str(ns(maximum))))
            plot(tmp, '../media/' + name + '.png', name)

    # (phase, tEmax; tDmax)
    tmp = list()
    tmp.append([30, 5.071824, 30])
    tmp.append([1, 0.059219, 1])

    print("taskset 1")
    sufficentTest(tmp)

    print("taskset 2")
    tmp = list()
    tmp.append([100, 11.796911, 100])
    sufficentTest(tmp)


    print("taskset 3")
    tmp = list()
    defTimeout = 35

#inf
    tmp.append([defTimeout,  0.233956, defTimeout])
    #rfid
    tmp.append([defTimeout, 13.108615, defTimeout])
    #us
    tmp.append([50, 10.275833, 50])
    sufficentTest(tmp)



if __name__ == '__main__':
    main()
